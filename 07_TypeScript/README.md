
# TypeScriptについて

JavaScriptによく似た型付き言語。  
JavaScriptへトランスパイル(変換)して使用する(TypeScriptはそのままではブラウザで解釈できないため)  

比較できるようにjavascriptとほぼ同じ構成にしている。  
Ctrl(Cmd) + クリックで 03xx.js と 07xx.ts を選択して、右クリック → 選択項目の比較で差分が確認できる。  

TypeScriptをインストール(事前にNodeのインストールが必要)

```
npm install -g typescript
```

TSLintインストール

```
npm install -g tslint
```

## jsファイルへ変換(トランスパイル)する

```
tsc -p 07_TypeScript/
```

tslint.jsonを元に構文チェックがおこなわれる。

# 0701_HelloWorld

実行

```
node built/0701_helloWorld.js
```

- 変数は代入前に使用することができない
- 数値と文字列の演算はできない
- 数値とundefinedの演算はできない
などできないことが増えている。  
主にバグを防ぐため。  

またvarはletとconstに分かれる。  
let → 可変値、再代入可能
const → 不変値、再代入不可  
またスコープの問題が発生するため全体を{}で囲っている。  

# 0702_type

宣言時に型を明示する。  
一意に型が定まる場合はある程度省略可能。  
interfaceを使用して独自の型を作成することができる。  

```
node 07_TypeScript/built/0702_type.js
```

# 0703_if_switch

JavaScriptとの違いを確認してみる。

```
node 07_TypeScript/built/0703_if_switch.js
```

# 0704_for_while

JavaScriptとの違いを確認してみる。  
1つの配列にいろいろな型を入れるのは型がわからなくなってしまうのであまり望ましくない。  
for文はより簡潔に記述されることが好まれる。  

```
node 07_TypeScript/built/0704_for_while.js
```

# 0705_function

JavaScriptとの違いを確認してみる。  
コールバック関数などを使用すると型が複雑になるが、不具合を埋め込む可能性が下がる。  

```
node 07_TypeScript/built/0705_function.js
```

# 0706_standardFunctions

JavaScriptとの違いを確認してみる。  
差異は少ないが危険なことができないようになっている。  

```
node 07_TypeScript/built/0706_standardFunctions.js
```

# 0707_Promise
JavaScriptとの違いを確認してみる。 

```
node 07_TypeScript/built/0707_Promise.js
``` 

# 0708_fizzbuzz
JavaScriptとの違いを確認してみる。 

```
node 07_TypeScript/built/0708_fizzbuzz.js
```  

# 0709_class

先に08~10 を参照することを推奨。  


## クラス（オブジェクト指向）について概要
おそらく万人が納得するような説明はこの世に存在しない。理解したい場合ライブラリやフレームワーク、実際に動作する洗練されたソフトウェアを参照するしかない。  
TypeScript,Java,Swift,PHPなど言語（フレームワーク）間でかなりアプローチが変わってくるので言語が違うだけで話が成立しない。  
雑に説明すると0個以上の状態(変数、プロパティ)を持った、何らかの機能(関数、メソッド)を持った集合。コピーしたり拡張したり相互に連携したりできる。  
機能を把握可能な単位(把握できないケースもある)でまとめたもの。  


## カプセル化
変更する必要のない値は変更できないようにしておくと捗る。  
変更可能な値が少ないほど考えることが減るのでハッピーになれる。  

## インヘリタンス（継承）
元のクラス（機能）を拡張したい時に使う。  
コンポジションの方が推奨されている。  
実装のお約束。  

## コンポジション
複数のクラスを持つクラス。  
継承とほぼ同様のことが実現可能。  

## デリゲート（委譲）
ある機能を別のクラスに委ねる。  
言葉だけだと理解が困難なので実装を参照する（良い例はあまり見当たらない）  
JavaScriptだと処理(関数)そのものを受け渡すケースも多い。  
実装のお約束。  

## インタフェース
該当のクラスを使うために必要な機能のガワを羅列したもの。テンプレート。あるいはクラスの規格。  
継承して使う。  
実装のお約束。  
TypeScript固有の特徴として型を定義するという用途がある（一般的でない）  

## ポリモーフィズム（多様性）
元のクラス（機能）を拡張したい時に使う。  
インターフェースなどによって実現される。  
実装のお約束。   

## イミュータブル
状態の変わらないオブジェクトのこと。設計思想の一つ。  
ニュアンスとしては定数とほぼ同義。  
  
## デザインパターン(GOF)
オブジェクト指向を(主に古いJavaで)実現する方法、パターン。  
もっと簡単に実現する方法があるならそちらを利用する。  
実装のお約束。  

## メンバ変数について

### public変数
プロパティ構文を参照。  

### private変数
外部から見える必要のない値。  
主にクラス内部の状態を保持する目的で使用する。  
増やしても外部に影響はあまりないが内部構造は複雑になる。  

### protected変数
設計を見直す。  
言語機能によって表現が制限されている場合はやむなし。  

### プロパティ構文
実質パブリックな変数（というと怒る人がいる）  
主に再利用されるパラメータ(引数)として利用する。  
増えれば増えるほど指数関数的に複雑度が増すので極力増やさない。  
プロパティ(+セッタ)が0個の場合、状態の変わらない所謂イミュータブルなクラスになる(ただしJavaScriptのObject型だと事情が変わってくる)  

### ゲッタ
主にクラスの状態を取得するのに利用する。  
private変数をそのままあるいは加工して返す。  
ゲッタ内部で値を更新してはいけない。  
モダンな言語ならプロパティ構文で制御できる。  
TypeScriptならgetアクセサが使用できる。  
増やしても悪影響が少ない。  

### セッタ
使うパターンが思いつかない。  
値セット時に外部にイベントを通知するパターンは可読難易度を上げるので気をつける。  

### セッタ・ゲッタ
≒パブリック変数  
カプセル化されていない。  
イミュータブルではない。  
両方使われることは言語機能で制約がない限り今はないはず。  
アクセス制御はプロパティ構文でおこなう。  
参照及び更新の確認はIDEの機能を利用する。  

## メンバ関数について  

0以上の引数と0以上のメンバ変数を入力に何かしらの出力を返す  


## static変数
定数  
何となくクラスに関係してそうだったら使用する  
publicはグローバルな定数  
privateはクラス内でのみ使用される定数  

## static関数
単体で存在可能な機能、関数  
何となくクラスに関係してそうだったら使用する  
publicはグローバルな関数  
privateはクラス内でのみ使用される関数  

# TypeScriptによるクラス実装例

いくら解説してもキリがないので実際に例を挙げて説明する。

```
node 07_TypeScript/built/0709_helloClass.js
```  

イミュータブルなDateTimeクラスを作成してみる。

```
node 07_TypeScript/built/0709_dateTime.js
```

## クラスを使わず日付処理をしてみる

07_TypeScript/built/0709_dateTime.js
と同じ機能を自分で実装してみる。
できれば0709_dateTime.tsを参照せずに実装して見てほしい。

1. 現在日付をyyyy/MM/dd形式で表示する
2. 現在日付をyyyy-MM-dd形式で表示する
3. 現在日付をyyyy年MM月dd日形式で表示する
4. 2018/01/01から1年後を計算してyyyy/MM/dd形式で表示する
5. 4からさらに2ヶ月後を計算してyyyy/MM/dd形式で表示する
6. 6からさらに3日前を計算してyyyy/MM/dd形式で表示する

## DateTimeクラスに足りない機能を補ってみる

時分秒について実装されていないで実装してみる。

- toStringメソッドが時分秒:hhmmssに対応できるようにする
- addHour, addMinute, addSecondを実装する

# 演習

## 1~nまで合計した値を表示する

07_TypeScript/0710_practice_1.ts に実装してみる。

解答例は 07_TypeScript/0710_practice_1_example.ts

```
node 07_TypeScript/built/0710_practice_1_example.js
```


## 配列の値を全て合計した結果を表示する


07_TypeScript/0710_practice_2.ts に実装してみる。

解答例は 07_TypeScript/0710_practice_2_example.ts

```
node 07_TypeScript/built/0710_practice_2_example.js
```

## 配列を反転する

07_TypeScript/0710_practice_3.ts に実装してみる。

解答例は 07_TypeScript/0710_practice_3_example.ts

```
node 07_TypeScript/built/0710_practice_3_example.js
```

## 0〜100まで100個のユニークな数値が入っている要素数100の配列を作成する


07_TypeScript/0710_practice_4.ts に実装してみる。

以下出力例  
0~100のうち25が入っていない。

```
[ 50,  80,  38,  37,  32,  98,  44,  55,  72,  51,  29,  83,  89,  52,  40,  84,  11,  15,  35,  39,  58,  64,  93,  59,  75,  41,  45,  63,  12,  71,  94,  7,  68,  23,  49,  61,  4,  70,  77,  78,  91,  81,  79,  76,  30,  85,  14,  100,  66,  9,  16,  46,  20,  48,  86,  97,  96,  92,  5,  42,  18,  95,  10,  54,  22,  62,  31,  21,  36,  43,  34,  87,  27,  1,  53,  73,  0,  57,  24,  56,  90,  60,  6,  67,  74,  2,  47,  65,  3,  13,  99,  28,  82,  8,  26,  69,  19,  88,  17,  33 ]
```

解答例は 07_TypeScript/0710_practice_4_example.ts

```
node 07_TypeScript/built/0710_practice_4_example.js
```

## 0〜100まで100個のユニークな数値が入っている配列から、一つ配列にない値を探す 5050

07_TypeScript/0710_practice_5.ts に実装してみる。

解答例は 07_TypeScript/0710_practice_5_example.ts

```
node 07_TypeScript/built/0710_practice_5_example.js
```


# 参考

公式
https://www.typescriptlang.org/docs/tutorial.html

日本語(若干情報が古い)
http://js.studio-kingdom.com/typescript/)
